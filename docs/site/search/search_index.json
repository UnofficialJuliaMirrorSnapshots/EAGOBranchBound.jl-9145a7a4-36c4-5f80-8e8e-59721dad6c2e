{
    "docs": [
        {
            "location": "/",
            "text": "EAGOBranchBound\n\n\nEAGOBranchBound contains a flexible branch and bound library. This package allows the user to specify termination criteria, lower & upper bounding problems, as well as search criteria.\n\n\n\n\nIntroduction\n\n\nMore text\n\n\n#\n\n\nEAGOBranchBound.BnBModel\n \u2014 \nType\n.\n\n\nBnBModel\n\n\n\n\nStores attributes of stack used to solve BnB problem. Has the following fields:\n\n\n\n\n\"Init_Box::Vector{Interval{Float64}}\": stores initial interval box used\n\n\nbox::Vector{Vector{Interval{Float64}}}     # interval box storage stack\n\n\nInit_Integer::Vector{Vector{Int64}}        # initial integer range\n\n\nintegers::Vector{Vector{Vector{Int64}}}    # integer range storage stack\n\n\nLBD::Vector{Float64}                       # lower bounds associated with each stack item\n\n\nUBD::Vector{Float64}                       # Upper bounds associated with each stack item\n\n\nid::Vector{Int64}                          # Node ID for each stack item\n\n\npos::Vector{Int64}                         # Position in BnB Tree for each stack item\n\n\nLBDg::Float64                              # Global Lower Bound\n\n\nUBDg::Float64                              # Global Upper Bound\n\n\nLBDg_hist::Vector{Float64}                 # Value history LBD problem\n\n\nUBDg_hist::Vector{Float64}                 # Value history UBD problem\n\n\nLBDgtime::Vector{Float64}                  # Run time history LBD problem\n\n\nUBDgtime::Vector{Float64}                  # Run time history UBD problem\n\n\nmax_id::Int64                              # Max node used\n\n\npstar::Vector{Interval{Float64}}           # IntervalBox with solution\n\n\nsoln::Vector{Float64}                      # Storage for solution\n\n\nsoln_val::Float64                          # Solution value found\n\n\nfirst_fnd::Bool                            # Has a solution been found\n\n\nfeas_fnd::Bool                             # Has a feasible point been found\n\n\nfirst_num::Int64                           # Iteration at which first solution found\n\n\nlbcnt::Int64                               # number of lower bounding problems solved\n\n\nubcnt::Int64                               # number of upper bounding problems solved\n\n\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.BnBSolver\n \u2014 \nType\n.\n\n\nBnBSolver\n\n\n\n\nStores solver specific functions used to solve BnB problem. Has the following fields: Lower_Prob::Any        # Stores lower problem function Upper_Prob::Any        # Stores upper problem function Term_Check::Any        # Stores termination check function Branch_Sto::Any        # Stores branching function Node_Select::Any       # Stores node selection function Bisect_Func::Any       # Stores branching function Verbosity::String      # Stores output selection max_iter::Number       # max number of iterations iter_lim::Bool         # determines if iteration limit is checked max_nodes::Int64       # max number of nodes to store in memory BnB_atol::Float64      # absolute tolerance for BnB BnB_rtol::Float64      # relative tolerance for BnB itr_intv::Int64        # number of iterations to skip between printing iteration summary hdr_intv::Int64        # number of iterations to skip between printing header converged::Any         # convergence criterion BnB_digits::Int64      # digits displayed before decimal hist_return::Bool      # returns LBD, UBD array and time vector opt::Any               # optional storage array exhaust::Bool          # exhaustive search: find all solns or find first target_upper::Float64\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.solveBnB!\n \u2014 \nFunction\n.\n\n\nsolveBnB!(x::BnBSolver,y::BnBModel)\n\n\n\n\nSolves the branch and bound problem with the input model and solver object.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.Bisect_Abs\n \u2014 \nFunction\n.\n\n\nBisect_Abs(S::BnBSolver,B::BnBModel,N::Vector{Interval{Float64}})\n\n\n\n\nReturns two interval boxes 'X1,X2' created by bisecting 'N' in the highest width dimension.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.Bisect_Abs_Imp\n \u2014 \nFunction\n.\n\n\nBisect_Abs_Imp(S::BnBSolver,B::BnBModel,N::Vector{Interval{Float64}})\n\n\n\n\nReturns two interval boxes 'X1,X2' created by bisecting 'N' in the highest width dimension greater than 'nx'.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.Bisect_Rel\n \u2014 \nFunction\n.\n\n\nBisect_Rel(S::BnBSolver,B::BnBModel,N::Vector{Interval{Float64}})\n\n\n\n\nReturns two interval boxes 'X1,X2' created by bisecting 'N' in the highest width dimension after scaling by initial box size.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.Bisect_Rel_Imp\n \u2014 \nFunction\n.\n\n\nBisect_Rel_Imp(S::BnBSolver,B::BnBModel,N::Vector{Interval{Float64}})\n\n\n\n\nReturns two interval boxes 'X1,X2' created by bisecting 'N' in the highest width dimension greater than 'nx' after scaling by initial box size.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.BM_breadth!\n \u2014 \nFunction\n.\n\n\nBM_breadth!(S::BnBSolver,B::BnBModel,tL::Float64,tU::Float64,\n            X1::Vector{Interval{Float64}},X2::Vector{Interval{Float64}},\n            pos::Int64)\n\n\n\n\nStores two interval boxes 'X1,X2' to the bottom of the stack along with their respective lower, 'tL' and upper bounds, 'tU' and their position number in the BnB tree. Also, assigns node numbers.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.BM_depth_best!\n \u2014 \nFunction\n.\n\n\nBM_depth_best!(S::BnBSolver,B::BnBModel,tL::Float64,tU::Float64,\n            X1::Vector{Interval{Float64}},X2::Vector{Interval{Float64}},\n            pos::Int64)\n\n\n\n\nStores two interval boxes 'X1,X2' to the top of the stack along with their respective lower, 'tL' and upper bounds, 'tU' and their position number in the BnB tree. Also, assigns node numbers.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.NS_best\n \u2014 \nFunction\n.\n\n\nNS_best(B::BnBModel)\n\n\n\n\nSelects node with the lowest upper lower bound. Returns (IntvBox,LBD,UBD,id,pos) where Intv is the intervalbox, LBD is the lower bound of the node, UBD is the upper bound of the node, id is the id number of the node, and pos is the position of the node in the BnB tree.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.NS_depth_breadth\n \u2014 \nFunction\n.\n\n\nNS_depth_breadth(B::BnBModel)\n\n\n\n\nSelects node on the top of the stack. Returns (IntvBox,LBD,UBD,id,pos) where Intv is the intervalbox, LBD is the lower bound of the node, UBD is the upper bound of the node, id is the id number of the node, and pos is the position of the node in the BnB tree.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.getsolution\n \u2014 \nFunction\n.\n\n\ngetsolution(x::BnBModel)\n\n\n\n\nReturns the solution stored in the BnBModel.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.getobjval\n \u2014 \nFunction\n.\n\n\ngetobjval(x::BnBModel)\n\n\n\n\nReturns the objective value stored in BnBModel (global upper bound).\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.getobjbound\n \u2014 \nFunction\n.\n\n\ngetobjbound(x::BnBModel)\n\n\n\n\nReturns the objective value stored in BnBModel (global upper bound).\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.getfeasibility\n \u2014 \nFunction\n.\n\n\ngetfeasibility(x::BnBModel)\n\n\n\n\nReturns feasibility of problem (feasible point found?).\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.LBDtime\n \u2014 \nFunction\n.\n\n\nLBDtime(x::BnBModel)\n\n\n\n\nReturns time spent solving lower bounding problem.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.UBDtime\n \u2014 \nFunction\n.\n\n\nUBDtime(x::BnBModel)\n\n\n\n\nReturns time spent solving upper bounding problem.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.set_Branch_Scheme!\n \u2014 \nFunction\n.\n\n\nset_Branch_Scheme!(x::BnBSolver,BM::String)\n\n\n\n\nSets the search scheme to \"best\", \"breadth\", or \"depth\" first schemes.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.set_Bisect_Func!\n \u2014 \nFunction\n.\n\n\nset_Bisect_Func!(x::BnBSolver,BF::String,nx::Int64)\n\n\n\n\nSets the bisection function to BF = \"relative midpoint\" or BF = \"absolute midpoint\" and disregards the first nx components of the interval box storage.\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.set_Verbosity!\n \u2014 \nFunction\n.\n\n\nset_Verbosity!(x::BnBSolver,VB::String)\n\n\n\n\nSets the verbosity (console output) to either \"None\", \"Normal\", or \"Full\".\n\n\nsource\n\n\n#\n\n\nEAGOBranchBound.set_to_default!\n \u2014 \nFunction\n.\n\n\nset_to_default!(x::BnBSolver)\n\n\n\n\nReturns the B&B solver to the default settings.\n\n\nsource\n\n\n\n\nEAGOBranchBound.BnBModel\n\n\nEAGOBranchBound.BnBSolver\n\n\nEAGOBranchBound.BM_breadth!\n\n\nEAGOBranchBound.BM_depth_best!\n\n\nEAGOBranchBound.Bisect_Abs\n\n\nEAGOBranchBound.Bisect_Abs_Imp\n\n\nEAGOBranchBound.Bisect_Rel\n\n\nEAGOBranchBound.Bisect_Rel_Imp\n\n\nEAGOBranchBound.LBDtime\n\n\nEAGOBranchBound.NS_best\n\n\nEAGOBranchBound.NS_depth_breadth\n\n\nEAGOBranchBound.UBDtime\n\n\nEAGOBranchBound.getfeasibility\n\n\nEAGOBranchBound.getobjbound\n\n\nEAGOBranchBound.getobjval\n\n\nEAGOBranchBound.getsolution\n\n\nEAGOBranchBound.set_Bisect_Func!\n\n\nEAGOBranchBound.set_Branch_Scheme!\n\n\nEAGOBranchBound.set_Verbosity!\n\n\nEAGOBranchBound.set_to_default!\n\n\nEAGOBranchBound.solveBnB!\n\n\n\n\n\n\nUser Documentation",
            "title": "Introduction"
        },
        {
            "location": "/#eagobranchbound",
            "text": "EAGOBranchBound contains a flexible branch and bound library. This package allows the user to specify termination criteria, lower & upper bounding problems, as well as search criteria.",
            "title": "EAGOBranchBound"
        },
        {
            "location": "/#introduction",
            "text": "More text  #  EAGOBranchBound.BnBModel  \u2014  Type .  BnBModel  Stores attributes of stack used to solve BnB problem. Has the following fields:   \"Init_Box::Vector{Interval{Float64}}\": stores initial interval box used  box::Vector{Vector{Interval{Float64}}}     # interval box storage stack  Init_Integer::Vector{Vector{Int64}}        # initial integer range  integers::Vector{Vector{Vector{Int64}}}    # integer range storage stack  LBD::Vector{Float64}                       # lower bounds associated with each stack item  UBD::Vector{Float64}                       # Upper bounds associated with each stack item  id::Vector{Int64}                          # Node ID for each stack item  pos::Vector{Int64}                         # Position in BnB Tree for each stack item  LBDg::Float64                              # Global Lower Bound  UBDg::Float64                              # Global Upper Bound  LBDg_hist::Vector{Float64}                 # Value history LBD problem  UBDg_hist::Vector{Float64}                 # Value history UBD problem  LBDgtime::Vector{Float64}                  # Run time history LBD problem  UBDgtime::Vector{Float64}                  # Run time history UBD problem  max_id::Int64                              # Max node used  pstar::Vector{Interval{Float64}}           # IntervalBox with solution  soln::Vector{Float64}                      # Storage for solution  soln_val::Float64                          # Solution value found  first_fnd::Bool                            # Has a solution been found  feas_fnd::Bool                             # Has a feasible point been found  first_num::Int64                           # Iteration at which first solution found  lbcnt::Int64                               # number of lower bounding problems solved  ubcnt::Int64                               # number of upper bounding problems solved   source  #  EAGOBranchBound.BnBSolver  \u2014  Type .  BnBSolver  Stores solver specific functions used to solve BnB problem. Has the following fields: Lower_Prob::Any        # Stores lower problem function Upper_Prob::Any        # Stores upper problem function Term_Check::Any        # Stores termination check function Branch_Sto::Any        # Stores branching function Node_Select::Any       # Stores node selection function Bisect_Func::Any       # Stores branching function Verbosity::String      # Stores output selection max_iter::Number       # max number of iterations iter_lim::Bool         # determines if iteration limit is checked max_nodes::Int64       # max number of nodes to store in memory BnB_atol::Float64      # absolute tolerance for BnB BnB_rtol::Float64      # relative tolerance for BnB itr_intv::Int64        # number of iterations to skip between printing iteration summary hdr_intv::Int64        # number of iterations to skip between printing header converged::Any         # convergence criterion BnB_digits::Int64      # digits displayed before decimal hist_return::Bool      # returns LBD, UBD array and time vector opt::Any               # optional storage array exhaust::Bool          # exhaustive search: find all solns or find first target_upper::Float64  source  #  EAGOBranchBound.solveBnB!  \u2014  Function .  solveBnB!(x::BnBSolver,y::BnBModel)  Solves the branch and bound problem with the input model and solver object.  source  #  EAGOBranchBound.Bisect_Abs  \u2014  Function .  Bisect_Abs(S::BnBSolver,B::BnBModel,N::Vector{Interval{Float64}})  Returns two interval boxes 'X1,X2' created by bisecting 'N' in the highest width dimension.  source  #  EAGOBranchBound.Bisect_Abs_Imp  \u2014  Function .  Bisect_Abs_Imp(S::BnBSolver,B::BnBModel,N::Vector{Interval{Float64}})  Returns two interval boxes 'X1,X2' created by bisecting 'N' in the highest width dimension greater than 'nx'.  source  #  EAGOBranchBound.Bisect_Rel  \u2014  Function .  Bisect_Rel(S::BnBSolver,B::BnBModel,N::Vector{Interval{Float64}})  Returns two interval boxes 'X1,X2' created by bisecting 'N' in the highest width dimension after scaling by initial box size.  source  #  EAGOBranchBound.Bisect_Rel_Imp  \u2014  Function .  Bisect_Rel_Imp(S::BnBSolver,B::BnBModel,N::Vector{Interval{Float64}})  Returns two interval boxes 'X1,X2' created by bisecting 'N' in the highest width dimension greater than 'nx' after scaling by initial box size.  source  #  EAGOBranchBound.BM_breadth!  \u2014  Function .  BM_breadth!(S::BnBSolver,B::BnBModel,tL::Float64,tU::Float64,\n            X1::Vector{Interval{Float64}},X2::Vector{Interval{Float64}},\n            pos::Int64)  Stores two interval boxes 'X1,X2' to the bottom of the stack along with their respective lower, 'tL' and upper bounds, 'tU' and their position number in the BnB tree. Also, assigns node numbers.  source  #  EAGOBranchBound.BM_depth_best!  \u2014  Function .  BM_depth_best!(S::BnBSolver,B::BnBModel,tL::Float64,tU::Float64,\n            X1::Vector{Interval{Float64}},X2::Vector{Interval{Float64}},\n            pos::Int64)  Stores two interval boxes 'X1,X2' to the top of the stack along with their respective lower, 'tL' and upper bounds, 'tU' and their position number in the BnB tree. Also, assigns node numbers.  source  #  EAGOBranchBound.NS_best  \u2014  Function .  NS_best(B::BnBModel)  Selects node with the lowest upper lower bound. Returns (IntvBox,LBD,UBD,id,pos) where Intv is the intervalbox, LBD is the lower bound of the node, UBD is the upper bound of the node, id is the id number of the node, and pos is the position of the node in the BnB tree.  source  #  EAGOBranchBound.NS_depth_breadth  \u2014  Function .  NS_depth_breadth(B::BnBModel)  Selects node on the top of the stack. Returns (IntvBox,LBD,UBD,id,pos) where Intv is the intervalbox, LBD is the lower bound of the node, UBD is the upper bound of the node, id is the id number of the node, and pos is the position of the node in the BnB tree.  source  #  EAGOBranchBound.getsolution  \u2014  Function .  getsolution(x::BnBModel)  Returns the solution stored in the BnBModel.  source  #  EAGOBranchBound.getobjval  \u2014  Function .  getobjval(x::BnBModel)  Returns the objective value stored in BnBModel (global upper bound).  source  #  EAGOBranchBound.getobjbound  \u2014  Function .  getobjbound(x::BnBModel)  Returns the objective value stored in BnBModel (global upper bound).  source  #  EAGOBranchBound.getfeasibility  \u2014  Function .  getfeasibility(x::BnBModel)  Returns feasibility of problem (feasible point found?).  source  #  EAGOBranchBound.LBDtime  \u2014  Function .  LBDtime(x::BnBModel)  Returns time spent solving lower bounding problem.  source  #  EAGOBranchBound.UBDtime  \u2014  Function .  UBDtime(x::BnBModel)  Returns time spent solving upper bounding problem.  source  #  EAGOBranchBound.set_Branch_Scheme!  \u2014  Function .  set_Branch_Scheme!(x::BnBSolver,BM::String)  Sets the search scheme to \"best\", \"breadth\", or \"depth\" first schemes.  source  #  EAGOBranchBound.set_Bisect_Func!  \u2014  Function .  set_Bisect_Func!(x::BnBSolver,BF::String,nx::Int64)  Sets the bisection function to BF = \"relative midpoint\" or BF = \"absolute midpoint\" and disregards the first nx components of the interval box storage.  source  #  EAGOBranchBound.set_Verbosity!  \u2014  Function .  set_Verbosity!(x::BnBSolver,VB::String)  Sets the verbosity (console output) to either \"None\", \"Normal\", or \"Full\".  source  #  EAGOBranchBound.set_to_default!  \u2014  Function .  set_to_default!(x::BnBSolver)  Returns the B&B solver to the default settings.  source   EAGOBranchBound.BnBModel  EAGOBranchBound.BnBSolver  EAGOBranchBound.BM_breadth!  EAGOBranchBound.BM_depth_best!  EAGOBranchBound.Bisect_Abs  EAGOBranchBound.Bisect_Abs_Imp  EAGOBranchBound.Bisect_Rel  EAGOBranchBound.Bisect_Rel_Imp  EAGOBranchBound.LBDtime  EAGOBranchBound.NS_best  EAGOBranchBound.NS_depth_breadth  EAGOBranchBound.UBDtime  EAGOBranchBound.getfeasibility  EAGOBranchBound.getobjbound  EAGOBranchBound.getobjval  EAGOBranchBound.getsolution  EAGOBranchBound.set_Bisect_Func!  EAGOBranchBound.set_Branch_Scheme!  EAGOBranchBound.set_Verbosity!  EAGOBranchBound.set_to_default!  EAGOBranchBound.solveBnB!",
            "title": "Introduction"
        },
        {
            "location": "/#user-documentation",
            "text": "",
            "title": "User Documentation"
        }
    ]
}